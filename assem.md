# Ассемблер основы

* Самое главное в процессоре это регистры
* Регистры в общем понимании являются переменными для работы процессора

## Регистры общего назначения (EAX, EBX, ECX, EDX)
**EAX, EBX, ECX, EDX** (32bit регистры). 

Младшие от 32bit : **AX, BX, CX, DX** (16bit делятся ещё на 2 части)

От 16bit :
* Младшие : **AL, BL, CL, DL** (8bit)
* Старшие : **AH, BH, CH, DH** (8bit)

## Регистры указатели (EIP, ESP, EBP, ESI, EDI)
**EIP, ESP, EBP, ESI, EDI** (32bit)
* Младшие : **IP, SP, BP, SI, DI** (16bit) 
* Старшие : **CS, DS, ES, FS, GS, SS** (16bit) 

## Сегментные регистры (CS, DS, ES, FS, GS, SS)
**CS, DS, ES, FS, GS, SS** (16bit) - Содержат первую половину **"оффсет.сегмента-а"**

## Регистр флагов
* Регистр флагов - **Хранилище битовой информации, каждый из 32 бит важен по отдельности**
* **Каждый бит кроме одного парного обозвали флагом**
* Eflags (32bit) : Flags (16bit)
* Нельзя просто записать значение(mov)
* Нет имени обращения

### Флаги процессора
* **ZF (Zero Flag - флаг нуля)** : Устанавливается в 1, если результат предыдущей операции = 0. Самое интересное, что флаг нуля переключается при **сравнении переменных (команда CMP)**
* **SF - флаг знака** : Всегда равен старшему биту результата
* **CF - флаг переноса** : Устанавливается в 1, если результат предыдущей операции над беззнаковыми числами не уместился в приёмник и прозошел перенос из старшего бита, или если требуется заем (при вычитании), иначе CF = 0
* **OF - флаг переполнения** : OF = 1, если результат пред. ариф. операции над числами со знаком выходит за допустимые для них пределы
* **AF - флаг полупереноса** : AF = 1, если в результате пред. операции произошел перенос или заем из третьего бита в четвертый.
* **PF - флаг четности** : PF = 1, если младший байт результата пред. команды содержит четное число битов, равных единице, инчае 0.
* **IF - флаг прерываний** : 1 - прерывание разрешены, 0 - запрещены
* **DF - флаг направления** : 0 - строки обрабатываются в сторону увеличения адресов, 1 - в сторону уменьшения адресов.


## Описание Регистров

* **E - Extended
* **EAX** (Accumulator)
* **EBX** (Base)
* **ECX** (Counter)
* **EDX** (Data)
* **EBP** (Base Pointer) - Указатель базы
* **ESP** (Stack Pointer) - Указатель стека
* **ESI** (Source Index) - Индекс источника
* **EDI** (Deliver Index) - Индекс приемника
* **EIP** (Instruction Pointer) - Регистр адреса текущей машинной команды (всегда содержит адрес след.команды процессора)

### Операнд в квадратных скобках - [bx], [si], [di]
* Когда операнд находится в квадратных скобках **([BX], [SI], [DI])**, это означает что нужно производить действие **по адресу в памяти**, указанному операндом (BX, SI, DI).
```
mov  dword ptr [ВX],04030201h ; Поместить в память по адресу 0133h 
                              ; значение 01020304h размером в 4 байта

add  dword ptr [BX],30303030h ; Прибавить к 4 байтам в памяти по адресу 0133h
                              ; значение 30303030h, размером в 4 байта.
```

## СТЕК
* Специально выделенная область памяти для передачи или сохранения данных.
* Стек растет вверх, дно стека по самому старшему адресу, вершина по младшему
* Значения извлекаются в обратном порядке
* На вершину стека указывает регистр-указатель **ESP** - это его значение
* Если в программе нужно много раз сохранять разные регистры, то лучше делать это через стек.
* Для записи в стек есть команда PUSH
* Для извлечения из стека команда POP


## КОМАНДЫ

### MOV
* Синтаксис - `MOV приемник, источник` **приемник = источник**
* **MOV** - Копирует содержимое источника в приемник. (не может передавать данные между двумя адресами ОП)
Пример :
```
mov ah, bh ; поместить значение регистра BH в регистр AH
mov ch, 09 ; поместить значение 9 в регистр CH
```

### NOP
* **NOP** - Команда ничего не делать

### ADD
* Синтаксис - `ADD приемник, источник`
* **ADD** - Прибавляет значение источника к приемнику : **приемник = приемник + источник**
* Для увеличения всего на еденицу используется команда **INC**

Пример :
```
add ah, bh ; прибавить значение регистра BH в регистр AH
add ch, 09 ; прибавить значение 9 в регистр CH
add eax, eax ; прибавить eax к самому себе (удвоить значение)
```

### ADC приемник, источник (сложение повышенной точности приемника, источника и флага CF)

### SUB
* Синтаксис - `SUB приемник, источник`
* **SUB** - Прибавляет значение источника к приемнику : **приемник = приемник - источник**
* Для уменьшения всего на еденицу используется команда **DEC**

Пример :
```
sub ah, bh ; отнять значение регистра BH из регистра AH
sub ch, 09 ; отнять значение 9 из регистра CH
sub eax, eax ; обнулить значение регистра eax
```

### SBB приемник, источник (вычитание из приемника,значения источника и флага CF)

### Операции сдвига SHL, SHR (сдвиг влево, сдвиг вправо)
* Синтаксис - `SHL регистр, 10h`
* Синтаксис - `SHR регистр, 10h`
* **SHL** - Сдвигает 2 младших байта на позиции 2-х старших байт (сдвиг влево)
* **SHR** - Сдвигает 2 старших байта на позиции 2-х младших байт (сдвиг вправо)
```
; Если регистр EAX = 0000BBBB

shl eax, 10h ; eax станет равен ВВВВ0000
shr eax, 10h ; eax станет снова равен 0000BBBB
```

### CMP - compare (сравнивать)
* Синтаксис - `CMP операнд1, операнд2`
* Сравнивает два операнда путем вычитания второго от первого
* **Результат может изменять 6 флагов (Eflags)**
* **Операнды не меняются**
```
mov ah, 10h  ; в AH значение 10h
cmp ah, 8    ; ZF = 0
cmp ah, 10h  ; ZF = 1
cmp ah, 0A0h ; ZF = 0
```

### JMP - Jump (Переход)
* Синтаксис `JMP адрес`
* Смена EIP на указанный адрес, переход туда
```
jmp 000000005
jmp 0aef41e0d
```

### JNZ (она же JNE) - Jump if Not Zero (Переход на адрес если не ноль)
* Синтаксис `JNZ адрес`
* Синтаксис2 `JNE адрес`
* Если **ZF=0**, то действует как JMP (смена EIP на указанный адрес, переход туда)
* Если **ZF=1**, то действие как у NOP (смена EIP на адрес след. команды)
* Команда противоположнего действия для JZ(JE)
```
jne 000000005
jnz 000000005
```

### XOR - e**X**clusive **OR** - исключающее ИЛИ
* Синтаксис `XOR приемник, источник`
* Побитовое исключающее или. 
* Если сравниваемые **биты равны**, то результат равен **0**
* Если сравниваемые **биты не равны**, то результат равен **1**
* Команда XOR обратима. Это значит, что поXORив её результат с одним из операндов, мы получим второй операнд.
```
xor eax, eax  ; обнуление регистра eax
```

### INC - increment (увеличение на 1)
* Синтаксис `INC operand`
* Увеличение операнда на еденицу
```
inc ax
inc b,[0161]
```

### DEC - decrement (уменьшение на 1)
* Синтаксис `DEC operand`
* Уменьшение операнда на еденицу
```
dec ax
dec b,[0161]
```

### PUSH - (положить в стек) ESP - регистр указывающий на вершину стека
* Синтаксис `PUSH register`
* Добавляет новое значение на вершину стека
* Если нужно положить в стек все 8 РОН используется команда PUSHA/PUSHAD
```
push eax 			; положить в стек из регистра eax
push 00403021 ; положить в стек
```

### POP - (извлечь из стека) ESP - регистр указывающий на вершину стека
* Синтаксис `POP register`
* Извлекает верхнее значение из стека
* Если нужно достать из стека все 8 РОН используется команда POPA/POPAD
```
pop eax 	; извлечь из стека в eax
pop ebx		; извлечь из стека в ebx
```

### XCHG операнд1, операнд2 (обменивает операнды местами)
```
						; если   al=45, ah=37
xchg al,ah 	; будет  al=37, ah=45
```

### AND|OR приемник,источник (логическое побитовое И|ИЛИ результат в приемник)
* Часто используется для выборочного обнуления|объединения отдельных битов.
```
and al, 00001111b  ; обнулит старшие 4 бита регистра al, а младшие не изменит
```

### TEST операнд1, операнд2 (выполняет команду and, опернды не меняет, меняет только флаги)

### NOT приемник - Инверсия (каждый бит приемника, равный нулю, устанавливается в 1 и наоборот)

