# Изучение Ассемблера через IDA pro [Link](https://wasm.in/blogs/vvedenie-v-reversing-s-nulja-ispolzuja-ida-pro-chast-2.4/)

## ВАЖНО Снимок базы данных
* Позволяет вернуться в предыдущее состояние базы
* ***FILE->Take database snapshot->Enter snapshot description*** - создание снимка
* ***VIEW->Database snapshot manager->Restore*** - вернуться к выбранному состоянию

## Системы счисления
* ДВОИЧНАЯ: Числа представляются двумя символами 0 и 1, вот почему она называется ДВОИЧНАЯ.
* ДЕСЯТИЧНАЯ: Все числа представляются с помощью 10 символов(от 0 до 9), вот почему она называется ДЕСЯТИЧНАЯ.
* ШЕСТНАДЦАТЕРИЧНАЯ: Все числа представляются с помощью символов от 0 до F ( от 0 до 9, далее A, B, C, D, E и F, или 16 символов в итоге).
* В нижней части IDA есть один коммандбар, чтобы исполнять команды PYTHON, он поможет переводить числа из одной системы в другую
  * ***0b*** означает двоичное представление числа
  * ***0x*** вначале числа конвертирует его в 16-ную систему : ***0x45*** = 69
  * Для 16-ных hex() : ***hex(69)*** = 0x45
  * Для двоичного  bin() : ***bin(69)*** = 0b1000101
  * Для символов chr() : ***chr(0x45)*** = E
* Для удобного управления преобразованиями в IDA есть калькулятор ***VIEW - CALCULATOR***
  * В 32-битных двоичных числах первый бит используется для знака числа, 0 = плюс, 1 = минус
  * ***7FFFFFFF*** : 2147483647 в десятичной (максимальное положительное число)
  * ***FFFFFFFF*** : -1 в десятичной
  * ***80000000*** : -2147483648 в десятичной (максимальное отрицательное число)

## Возможности поиска (пункт SEARCH)
* next code - поиск след. кода : CODE
* next data - поиск след. данных : DATA
* next [un]explored - поиск след. [не]распознанного блока
* next immediate - поиск след. непосредственного значения
* next text - поиск совпадения по тексту
* sequance binary - поиск последовательности байт
* not function - поиск неразобранных функций

## Data type
<table>
  <tr>
    <th>Data Type</th>
    <th>Bytes</th>
  </tr>
  <tr>
    <td>BYTE, SBYTE</td>
    <td>1</td>
  </tr>
  <tr>
    <td>WORD, SWORD</td>
    <td>2</td>
  </tr>
  <tr>
    <td>DWORD, SDWORD</td>
    <td>4</td>
  </tr>
  <tr>
    <td>FWORD</td>
    <td>6</td>
  </tr>
  <tr>
    <td>QWORD</td>
    <td>8</td>
  </tr>
  <tr>
    <td>TBYTE</td>
    <td>10</td>
  </tr>
</table>

## Регистры 32-битные
* ***EAX*** - аккумулятор + 16 бит - AX(8 бит AH + AL)
* ***EBX*** - база + 16 бит - BX(8 бит BH + BL)
* ***ECX*** - счетчик + 16 бит - CX(8 бит CH + CL)
* ***EDX*** - данные + 16 бит - DX(8 бит DH + DL)
* ***ESP*** - указатель на вершину стека
* ***EBP*** - указатель на базу стека
* ***ESI*** - указатель на источник данных
* ***EDI*** - указатель на назначенные данные

## Сегментные регистры
* ***CS*** - CODE Segment
* ***DS*** - DATA Segment
* ***SS*** - STACK Segment
* ***ES*** - Extra
* ***FS*** - Extra
* ***GS*** - Extra

## IAT (таблица с адресами внешних функций, при запуске)
* ***.idata*** - раздел (розовые строки)
* ***IAT*** - пустой и заполняется при запуске программы
* ***extrn*** - означает что это внешняя функция

## Инструкции
* ***OFFSET*** - передача самого адреса (не значения)
* ***dword_*** - передача данных типа DWORD
* ***stru_*** - передача данных типа структура
* ***loc_*** - локальная метка
* ***sub_*** - метка функции (ПКМ->Create function)
* ***Клавиша D*** - преобразование в DATA вид
* ***Клавиша A*** - преобразование в ASCII вид

### Изменение кода (плагин [github](https://github.com/keystone-engine/keypatch) [Keypatch](https://drive.google.com/file/d/0B13TW0I0f8O2eU1VdUJzVjdYTWs/view?usp=sharing))
***ПКМ->Keypatch->Patcher*** или ***Ctrl+Alt+K***
```
Во второй ссылке находится файл keypatch.py, 
который мы должны скопировать в каталог плагинов IDA 
и затем можно установить keystone-0.9.1-python-win32.msi.

Кроме того, необходимо установить Microsoft VC ++, 
библиотеку времени исполнения.
```

### MOV А, В (копирование из В в А)
Примеры :
* ***MOV EAX, EDI*** 
* ***MOV EAX, 1***
* ***MOV EAX, dword_46F908*** - передача содержимого адреса
* ***MOV EAX, offset dword_46F908*** - передача самого адреса 
* ***MOV EAX, DWORD PTR DS:[46F908]***
* ***MOV EAX, [EDI]*** - квадратные скобки если IDA не знает что в EDI
* ***MOV AL, 1***

### XCHG A, B (обмен значениями)
* ***XCHG EAX, ESI***
* ***XCHG EAX, DS:dword_4020DC*** - обмен EAX c содержимым адреса 4020DC

### PUSH (положить в стек)
* ***push 64h*** - положить в стек 0x64
* ***push eax*** - положить в стек значение из EAX
* ***push offset byte_4020E7*** - положить в стек адрес памяти (например адрес начало строки)

Передача аргумента к функциям : ***PUSH offset xxxxx***

### POP (вытащить из стека)
* ***pop edi*** - вершина стека в edi (esp меняется на след. в стеке)
* ***pop esi***
* ***pop ebx***

### Параметры в функциях в IDA
* В функциях обнаруженных IDA есть параметры.
* Передаются через ***PUSH*** который стоит перед вызовом функции(***CALL***)
* ***PUSH*** сохраняет эти значения(параметры) в стеке
```assembly
00401170 var_24= byte ptr -24h 
00401170 var_18= byte ptr -18h 
00401170 var_14= dword ptr -14h 
00401170 var_10= dword ptr -10h 
00401170 var_C= dword ptr -0Ch 
00401170 var_4= dword ptr -24 
00401170 arg_0= dword ptr 8 
```

### LEA A, B  (помещает указанный ***адрес*** из В в А)
* Никогда не получает доступ к содержимому В
* Либо адрес, либо результат работы операции между квадратными скобками в В.
* Используется чтобы ***получить адреса переменых*** в памяти или ***параметров***.
* ***lea eax, [ebp+var_C]*** - ebp используется как база с адресом стека Lea решает операцию [EBP - var_C(0C)] - получим адрес переменной
* ***Lea eax, [4 + 5]*** - поместит 9 в eax, а не содержимое адреса 0x9, как это делает MOV
<table>
  <tr>
    <th>LEA</th>
    <td>Получает адрес переменной</td>
  </tr>
  <tr>
    <th>MOV</th>
    <td>Получает значение по адресу</td>
  </tr>
</table>

### ADD A, B (сложение с результатом в А)
* А и В не должны быть в памяти в одно и то же время, в одной и той же инструкции
<table>
  <tr>
    <th>A</th>
    <td>Регистр</td>
    <td>Содержимое ячейки памяти</td>
  </tr>
  <tr>
    <th>В</th>
    <td>Регистр</td>
    <td>Содержимое ячейки памяти</td>
    <td>Константа</td>
  </tr>
</table>

* ***add al, 8***
* ***add bx, ax***
* ***add BYTE PTR DS: [eax], 7***

### SUB A, B (вычитает целое число В из А с результатом в А)
<table>
  <tr>
    <th>A</th>
    <td>Регистр</td>
    <td>Содержимое ячейки памяти</td>
  </tr>
  <tr>
    <th>В</th>
    <td>Регистр</td>
    <td>Содержимое ячейки памяти</td>
    <td>Константа</td>
  </tr>
</table>

* ***sub [ebp+arg_4], eax***
* ***sub esp, 8***
* ***esi, [eax+8]***

### INC A and DEC A (инкремент и декремент)
* ***inc eax***
* ***dec eax***

### IMUL (умножение со знаком)
<table>
  <tr>
    <th>A</th>
    <td>Регистр</td>
  </tr>
  <tr>
    <th>В</th>
    <td>Регистр</td>
    <td>Содержимое ячейки памяти</td>
  </tr>
  <tr>
    <th>С</th>
    <td>Константа</td>
  </tr>
</table>

#### ***IMUL A, B*** (умножение А на В с результатом в А)
* ***IMUL eax, [ecx]***

#### ***IMUL A, B, C*** (умножение В на С с результатом в А)
* ***IMUL esi, edi, 25***

### IDIV A (А - делитель)
* ***СУТЬ*** - Создает большое 64-битное число, старшая часть которого находится в ***EDX***, а младшая в ***EAX***. Делит значение на А и сохраняет результат в ***EAX***, а остаток значения в ***EDX***
* ***IDIV ecx*** - если ***EAX*** = 5, ***EDX*** = 0, ***ECX*** = 2, то выполнится деление 5 на 2. ИТОГ: ***EAX*** = 2, ***EDX*** = 1


## Логические операции AND, OR, XOR
<table>
  <tr>
    <th>A</th>
    <td>Регистр</td>
    <td>Содержимое ячейки памяти(ТОЛЬКО ОДИН)</td>
  </tr>
  <tr>
    <th>В</th>
    <td>Регистр</td>
    <td>Содержимое ячейки памяти(ТОЛЬКО ОДИН)</td>
  </tr>
</table>

<table>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>AND</th>
    <th>OR</th>
    <th>XOR</th>
  </tr>
  <tr>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>1</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
  </tr>
</table>

### AND A, B (логическое И с результатом в А)
* ***AND eax, 0F*** - 0F = 1111. В итоге нули во всех битах и нетронутые 4 последних бита
* Python>bin(0b11100111 & 0b1111) => 0b111

### OR A, B (логическое ИЛИ с результатом в А)
* Python>0x54 | 0x34 => 116

### XOR A, B (исключающее ИЛИ с результатом в А)
* Python>bin(0b111101 ^ 0b111101) => 0b0 (***XOR***)

### NOT A (инверсия всех битов в А)

### NEG A (превращает А в -А)
* Python>hex(~ 0x45+1) => -0x45
* Python>hex(~ -0x45+1) => 0x45

### SHL A, B и SHR A, B (сдвиг байтов слева и справа в А с заменой нулями с другой стороны)
<table>
  <tr>
    <th>A</th>
    <td>Регистр</td>
    <td>Содержимое ячейки памяти</td>
  </tr>
  <tr>
    <th>В</th>
    <td>8-бит. регистр</td>
    <td>Константа</td>
  </tr>
</table>

* ***SHL 0b1100, 2*** => ***0b0000***

### ROL A, B и ROR A, B (сдвиг байтов слева и справа в А с вращением битов)
* Биты которые уходят с одной стороны появляются с другой
* ***ROL 0b1100, 2*** => ***0b0011***

### JMP SHORT A (короткий переход вперед и назад - инструкция из 2 байт)
<table>
  <tr>
    <th>1 байт</th>
    <td>ОПКОД перехода(JMP=0xEB)</td>
  </tr>
  <tr>
    <th>2 байт</th>
    <td>Направление перехода</td>
  </tr>
</table>

* ***IDA: 00401324 EB 05 - JMP short loc_40132b***
* ***ВАЖНО*** - Всегда добавляем размер инструкции при переходе
* Python>***hex(0x401324 + 2 + 5)*** => ***0x40132b*** - Начальный адрес инструкции + ***2*** (количество байт инструкции JMP SHORT) + ***05*** (значение второго байта)
* Максимальный переход вперёд будет равен ***0x7F***
* Максимальный переход назад будет равен ***0x80***
* Минимальный переход назад ***-1*** = ***0xFF***
* В Python ***-0x80*** в 16-ном значении равно ***0xFFFFFF80***
* Python>***hex((0x401324 + 2 +0xFFFFFF80) & 0xFFFFFFFF)*** => ***0x4012a6L***
* Python>***hex((0x401324 + 2 +0xFFFFFFff) & 0xFFFFFFFF)*** => ***0x401325L***
* Python>***hex((0x401324 + 2 +0xFFFFFFfE) & 0xFFFFFFFF)*** => ***0x401324L*** - Переход к начальной инструкции(Бесконечный цикл)

### JMP A (длинный переход по адресу А)
* ***IDA: 004026AE E9 00 03 00 00 - JMP loc_4029B3***
* Python>***hex(0x4029b3 -0x4026ae -5)*** => ***0x300(стоит рядом с опкодом Е9)*** - Где размер инструкции равен 5
* Python>***hex(0x400000 -0x4026ae -5)*** => ***-0x26b3*** = ***0xFFFFD94D*** в итоге получается :
  * ***IDA: 004026AE E9 4D D9 FF FF - JMP near ptr 400000h***

## Условные переходы
* ***ВАЖНО*** - после сравнение **изменяются важные ФЛАГИ**
<h2>Таблица условных переходов</h2>
<table>
  <tr>
    <th>ASM</th>
    <td>jne</td>
    <td>je</td>
    <td>ja</td>
    <td>jna</td>
    <td>jae</td>
    <td>jnae</td>
    <td>jb</td>
    <td>jnb</td>
    <td>jbe</td>
    <td>jnbe</td>
    <td>jg</td>
    <td>jng</td>
    <td>jge</td>
    <td>jnge</td>
    <td>jl</td>
    <td>jnl</td>
    <td>jle</td>
    <td>jnle</td>
  </tr>
  <tr>
    <th>Hex</th>
    <td>75 0f85</td>
    <td>74 0f84</td>
    <td>77 0f87</td>
    <td>0f86</td>
    <td>0f83</td>
    <td>0f82</td>
    <td>0f82</td>
    <td>0f83</td>
    <td>0f86</td>
    <td>0f87</td>
    <td>0f8f</td>
    <td>0f8e</td>
    <td>0f8d</td>
    <td>0f8c</td>
    <td>0f8c</td>
    <td>0f8d</td>
    <td>0f8e</td>
    <td>0f8f</td>
  </tr>
</table>

### CMP A, B (сравнение)
* ***CMP*** - вычитает оба регистра и если они равны, результатом будет **0**. В переходе ***JZ***, **0** активирует **ФЛАГ Z** = true то есть переход по зеленой стрелке, иначе переход по красной стрелке = false 
* Пример : ***jz short loc_40124c***

### CALL (вызов функции)
* Сохраняет на **ВЕРШИНЕ** стэка адрес возврата
* ***call sub_4013d8***

### RET (возврат функции)
* Возврат к инструкции следующей за тем, где был вызов ***CALL***
* Берёт адрес возврата сохраненный в стеке и переходит туда
* ***IDA : 004013fd retn*** - возврат из функции

## Стат. анализ на примере Cruehad

### Сегменты
* ***VIEW->OPEN SUBVIEW->SEGMENTS***
* ***ЗАГОЛОВОК*** по адресу ***0x400000*** перед секциями не загружен, так настроено в настройках. Он загружает только некоторые исполняемые секции автоматически без **ЗАГОЛОВКА**
<h2>Таблица SEGMENTS</h2>
<table>
  <tr>
    <th>Name</th>
    <th>Start</th>
    <th>End</th>
    <th>R(Read)</th>
    <th>W(Write)</th>
    <th>X(Exec)</th>
    <th>D</th>
    <th>L</th>
  </tr>
  <tr>
    <th>Имя секции</th>
    <th>Адрес начала</th>
    <th>Адрес конца</th>
    <th>Чтение</th>
    <th>Запись</th>
    <th>Выполнение</th>
    <th>Отладчик</th>
    <th>Загрузчик</th>
  </tr>
</table>

* Для загрузки **ЗАГОЛОВКА** с адресом **0x400000** необходимо :
  * Стереть старый проект и создать новый
  * При создании включить галочку ***MANUAL LOAD***
  * Жмем ОК и YES
  * Теперь можно будет изменять больше данных

