# C# Изучение

## Дополнительные разделы
* [Вопросы для самопроверки ](questions.md)
* [Основные понятия](definition.md)
* [Конспект по курсу "Продвинутый C# Шаг1"](synopsis1.md)
* [____](____)
---
## <a name="0">Навигация</a>
<details>
  <summary><b>Понятия</b></summary>

  * [Составное форматирование](#1_1)
  * [Интерполяция строк](#1_2)
</details>

<details>
  <summary><b>Основы</b></summary>

  * [Типы данных](#2_1)
      * [Краткий список](#2_1_1)
      * [***var*** неявная типизация](#2_1_2)
      * [Преобразование типов](#2_1_3)
      * [Инкремент(декремент)](#2_1_4)
  * [Логические операции](#2_2) (`&, |, ^, ~, <<, >>`)
  * [Операции присваивания](#2_3)
  * [Преобразования базовых типов](#2_4)
  * [Условные логические операции](#2_5) (`|, ||, &, &&, !, ^`)
  * [Условные конструкции](#2_6)
  * [Циклы](#2_7)
  * [Массивы](#2_8)
      * [Многомерные массивы](#2_8_1)
      * [Простой перебор двумерного массива](#2_8_2)
      * [Перебор двум.мас. по каждой строке столбца](#2_8_3)
      * [Массив массивов (зубчатый массив)](#2_8_4)
  * [Методы](#2_9)
      * [Сокращенная запись методов](#2_9_1)
      * [Параметры методов](#2_9_2)
      * [Передача параметров (ref, out)](#2_9_3)
      * [Массив параметров (params)](#2_9_4)
  * [Рекурсивные фун-ции](#2_10)
  * [Перечисления enum](#2_11)
  * [Кортежи](#2_12)
      * [Использование кортежей в функциях](#2_12_1)
</details>

<details>
  <summary><a name="3"><b>Классы (ООП)</b></a></summary>

  * [Ключевое слово this в классах](#3_1)
  * [Инициализаторы объектов](#3_2)
  * [Организация памяти в .NET](#3_3)
  * [Типы значений и ссылочные типы](#3_4)
  * [Передача параметров по значению и по ссылке (***ref***)](#3_5)
  * [Модификаторы доступа (допустимая область видимости)](#3_6)
  * [Свойства (специальные методы доступа)](#3_7)
  * [Автоматические свойства(АС)](#3_8)
  * [Перегрузка методов](#3_9)
  * [Модификатор static (статические элементы СЭ)](#3_10)
  * [Константы и поля для чтения (const, readonly)](#3_11)
  * [Перегрузка операторов (`- + < > ...`)](#3_12)
  * [Значение Null (отсутствие значения)](#3_13)
  * [Индексаторы](#3_14)
  * [Наследование (inhertiance)](#3_15)
  * [Ключевое слово ***base***](#3_16)
  * [Преобразование типов (object)](#3_17)
    * [Способы преобразования типов](#3_17_1)
  * [Перегрузка операций преобразования типов](#3_18)
  * [Полиморфизм. Виртуальные методы и свойства (***virtual***)](#3_19)
  * [Сокрытие (shadowing/hiding)](#3_20)
  * [Абстрактные классы](#3_21)
  * [Абстрактные члены классов](#3_22)
  * [Класс System.Object и его методы](#3_23)
  * [Обобщения .NET v2.0 (generics)](#3_24)
    * [Значение по умолчанию (***default(T)***)](#3_24_1)
    * [Статические поля обобщенных классов](#3_24_2)
    * [Использование нескольких универсальных параметров](#3_24_3)
    * [Обобщенные методы](#3_24_4)
  * [Ограничения обобщений](#3_25)
  * [Наследование обобщенных типов](#3_26)
    * [Сочетание своих параметров и базового класса](#3_26_1)
</details>

<details>
  <summary><a name="4"><b>Обработка исключений</b></a></summary>

  * [Конструкция try...catch...finally](#4_1)
  * [Блок ***catch*** и фильтры исключений](#4_2)
    * [Фильтры исключений](#4_2_1)
  * [Типы исключений. Класс Exception](#4_3)
  * [Создание классов исключений](#4_4)
  * [Поиск блока catch при обработке исключения](#4_5)
  * [Генерация исключения и оператор throw](#4_6)
</details>

<details>
  <summary><a name="5"><b>Интерфейсы</b></a></summary>

  * [Введение в интерфейсы](#5_1)
    * [Множественная реализация интерфейсов](#5_1_1)
    * [Интерфейсы в преобразованиях типов](#5_1_2)
  * [Наследование интерфейсов](#5_2)
    * [Изменение реализации интерфейсов в производных классах](#5_2_1)
    * [Явная реализация интерфейсов (ЯРИ)](#5_2_2)
  * [Интерфейсы в обобщениях](#5_3)
    * [Обобщенные интерфейсы](#5_3_1)
  * [Копирование объектов. Интерфейс ICloneable](#5_4)
  * [Сортировка объектов. Интерфейс IComparable](#5_5)
    * [Применение компаратора](#5_5_1)
  * [Ковариантность и контравариантность обобщенных интерфейсов](#5_6)
    * [Ковариантные интерфейсы](#5_6_1)
    * [Контравариантные интерфейсы](#5_6_2)
</details>

<details>
  <summary><a name="6"><b>Делегаты, события и лямбды</b></a></summary>

  * [_____](#6)
  * [_____](#6_1)

</details>

---
## [&uarr;](#0)  <a name="1">Понятия</a>
### [&uarr;](#0)  <a name="1_1">1) Составное форматирование - строка с индексированными местозаполнителями</a>
* Индексированные местозаполнители `{0}` соответствуют объектам из списка `name`
* Поддерживают следующие **методы** :
```php
Console.WriteLine
String.Format
StringBuilder.AppendFormat
TextWriter.WriteLine
StreamWriter
HtmlTextWriter
Debug.WriteLine
Trace.TraceError
Trace.TraceInformation
Trace.TraceWarning
TraceSource.TraceInformation
```
* Пример :
```c#
string name = "Fred";
int age = 33;
Console.WriteLine("Имя = {0}, возраст = {1}", name, age);
// Output : "Имя = Fred, возраст = 33"
```

### [&uarr;](#0)  <a name="1_2">2) Интерполяция строк - внедрение любого выражения в строку </a>
* Интерполированная строка начинается с символа **$**
* Между символом **$** и знаком кавычки не должно быть пробелов
* *Интерполированное выражение* обозначается фигурными скобками `{выражение}`
* Условный оператор заключается в круглые скобки `{(условный оператор)}`
* Примеры :
```c#
string name = "Tom";
int age = 22;
Console.WriteLine($"Hello, {name}! Your age is {age}"); // стандартная интерполяция
Console.WriteLine($"{name} is {age} year{(age == 1 ? "true" : "false")} old."); // условный оператор
```

---
## [&uarr;](#0)  <a name="2">Основы</a>

### [&uarr;](#0)  <a name="2_1">Типы данных</a>

#### [&uarr;](#0)  <a name="2_1_1">1) Краткий список</a>

```c#
bool    - System.Boolean
byte    - System.Byte    (1 byte): 0...255
sbyte   - System.SByte   (1 byte):-128...127
short   - System.Int16   (2 bytes):-32.768...32.767
ushort  - System.UInt16  (2 bytes):0...65.535
int     - System.Int32   (4 bytes):-2.147.483.648...2.147.483.647 (int a = 5)
uint    - System.UInt32  (4 bytes):0...4.294.967.295 (uint a = 5u)
long    - System.Int64   (8 bytes):-9.223.372.036.854.775.808...9.223.372.036.854.775.807 (long a = 5l)
ulong   - System.UInt64  (8 bytes):0...18.446.744.073.709.551.615 (ulong a = 5ul)
float   - System.Single  (4 bytes):-3.4*10^38...3.4*10^38 (float a = 3.14f)
double  - System.Double  (8 bytes):+-5.0*10^-324...+-1.7*10^308 (double a = 3.14) (15 знаков после запятой)
decimal - System.Decimal (16bytes):+-1.0*10^-28...+-7.9228*10^28 (decimal a = 3.14m) (28 знаков после запятой)
char    - System.Char    (2 bytes)
string  - System.String  (набор символов Unicode)
object  - System.Object  (4-8 bytes 32x-64x)
enum		- System.Enum    (набор значений)
```

#### [&uarr;](#0)  <a name="2_1_2">2) ***var*** - Неявная типизация</a>
* При объявлении всегда задается значение
* Не может быть = null
```c#
var str = "Hello"; // верно
var c = 20;        // верно
var d;             // ошибка
var n = null;      // ошибка
```

#### [&uarr;](#0)  <a name="2_1_3">3) Преобразование типов</a>
```c#
string num = "35";
Convert.ToInt32(num) // к типу int
Convert.ToDouble(num) // к типу double
Convert.ToDecimal(num) // к типу decimal
```

#### [&uarr;](#0)  <a name="2_1_4">4) Инкремент(декремент)</a>
```c#
int i=0;
Console.WriteLine(i++ + ") i = " + i);   // out: 0) i = 1
Console.WriteLine(i++ + ") i = " + ++i); // out: 1) i = 3
```

### [&uarr;](#0)  <a name="2_2">Логические операции (&, |, ^, >>, <<)</a>
* ***&*** (логическое умножение) - поразрядное умножение в двоичном виде
```c#
int x = 2;       //  010 = 2
int y = 5;       //  101 = 5
                 // *
int sum = x & y; //  000 = 0
```
* ***|*** (логическое сложение) - поразрядное сложение в двоичном виде
```c#
int x = 3;       //  011 = 3
int y = 5;       //  101 = 5
                 // +
int sum = x | y; //  111 = 7
```
* ***^*** (логическое исключающее ИЛИ - XOR) - если значения разные ? 1 : 0
```c#
int x = 3;       //  011 = 3
int y = 5;       //  101 = 5
                 // ^
int sum = x ^ y; //  110 = 6
```
* ***~*** (логическое отрицание или инверсия)
```c#
// При инверсии меняем знак и отнимаем ещё еденицу
int x = 12;       //  00001100 =  12
                  // ~          (-12 - 1)
int result = ~x;  //  11110011 = -13
```
* ***>>, <<*** (операции сдвига разрядов)
```c#
int x = 4;            //   100  = 4
                      // <<
int result = x << 1;  //   1000 = 8

x = 4;                //   100 = 4
                      // >>
int result = x >> 1;  //   10  = 2
```

### [&uarr;](#0)  <a name="2_3">Операции присваивания</a>
```c#
int a = 10;
a += 10;    // = 20
a -= 4;     // = 16
a *= 2;     // = 32
a /= 8;     // = 4  =     100b
a <<= 4;    // = 64 = 1000000b
a >>= 2;    // = 16 =   10000b
a >>= 2;    // = 4  =     100b 
            // 6    =    *110b
a &= 6;     // = 4  =     100b
            // 9    =   +1001b
a |= 9;     // = 13 =    1101b
            // 15   =   ^1111b
a ^= 15;    // = 2  =    0010b
```

### [&uarr;](#0)  <a name="2_4">Преобразования базовых типов</a>
* Операции сложения(+) и вычитания(-) возвращают значение типа int, если нет типа данных больше чем int
```c#
byte a = 4;
byte b = a + 70;         // ошибка
byte b = (byte)(a + 70); // верно
``` 
* Расширяющие(неявное) преобразование [таблица](https://metanit.com/sharp/tutorial/pics/2.9.png) - дополнение разрядностей 

[Положительное число](https://metanit.com/sharp/tutorial/pics/2.7.png)
```c#
byte a = 4;   //         0000100b
ushort b = a; // 000000000000100b (a>0 дополнение нулями)
```
[Отричательное число](https://metanit.com/sharp/tutorial/pics/2.8.png)
```c#
sbyte a = -4; //         1111100b
short b = a;  // 111111111111100b (a<0 дополнение еденицами)
```
* Сужающие(явное) преобразование - в скобках указывается нужный тип данных 
```c#
ushort c = 4;      // 000000000000100b
byte d = (byte) c; //         0000100b
```
* Проверка на переполнение (***checked***) - выбрасывает исключение OverflowException
```c#
try {
	int a = 33;
	int b = 600;
	byte c = checked((byte)(a+b));
} catch (OverflowException ex) {}
```

### [&uarr;](#0)  <a name="2_5">Условные логические операции (`|, ||, &, &&, !, ^`)</a>
* Операции `&&, ||` и `&, |` возвращают одинаковый результат, но работают по разному
* Операции `&&, ||` работают до первого успеха/отказа (true/false)
* Операции `&, |` работают до конца в любом случае
```c#
int a = 3;
int b = 3;
bool c;
c = (a++ > 0 || b++ > 0); // a = 4, b = 3 (a-changed, b-not)
c = (a++ > 0 |  b++ > 0); // a = 5, b = 4 (a,b - changed)
c = (a++ >10 && b++ > 0); // a = 6, b = 4 (a-changed, b-not)
c = (a++ >10 &  b++ > 0); // a = 7, b = 5 (a,b - changed)
```
* Операция `!`(отрицания) меняет ***true*** на ***false*** и наоборот
* Операция `^`(XOR) дает ***true*** если операнды разные и ***false*** если одинаковые
```c#
bool a = true;  // a = true
bool b = !a;    // b = false
bool c = a ^ b  // c = true
bool d = a ^ !b // d = false
```

### [&uarr;](#0)  <a name="2_6">Условные конструкции</a>
* if/else
* switch напоминалка :
```c#
switch (value) {
	case 1:
		Console.WriteLine("1");
		break;
	case "Y":
		Console.WriteLine("Yes");
		break;
	default:
		Console.WriteLine("Default");
		break;
}
```
* Тернарная операция - `(condition) ? true : false;`
```c#
//             (condition) ?   true   :  false  ;
string result = (55 > 60)  ? "Wrong!" : "Right!"; // result = "Right!"
```

### [&uarr;](#0)  <a name="2_7">Циклы</a>
* for
* while
* do...while
* foreach - `foreach (тип_данных название_переменной in контейнер) {действия}`
```c#
int[] numbers = new int[] {1,2,3,4,5};

foreach (int i in numbers) {
	Console.WriteLine(i);
}
```

### [&uarr;](#0)  <a name="2_8">Массивы</a> [Примеры](https://metanit.com/sharp/tutorial/pics/array.png)
* ***Ранг***(rank): количиство измерений массива
* ***Длина измерения***(dimension length): длина отдельного измерения массива
* ***Длина массива***(array length): количество всех элементов массива
```php
// Квадратные скобки ставятся после типа переменной
int[] numbers;  // верно
int numbers2[]; // ошибка

// Размер массива не может быть указан в объявлении переменной
int[] numbers3;   // верно
int[2] numbers4;  // ошибка

// При создании массива размер массива указывается обязательно
int[] numbers3 = new int[2]; // верно
int[] numbers4 = new int[];  // ошибка

// Примеры правильного создания простого массива
int[] nums1 = new int[4] { 1, 2, 3, 5 };
int[] nums2 = new int[] { 1, 2, 3, 5 };
int[] nums3 = new[] { 1, 2, 3, 5 };
int[] nums4 = { 1, 2, 3, 5 };
```

#### [&uarr;](#0)  <a name="2_8_1">1) Многомерные массивы</a>
```c#
// Двухмерный массив
int[,] nums1;
int[,] nums2 = new int[2, 3];
int[,] nums3 = new int[2, 3] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums4 = new int[,] { { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums5 = new [,]{ { 0, 1, 2 }, { 3, 4, 5 } };
int[,] nums6 = { { 0, 1, 2 }, { 3, 4, 5 } };

// Трехмерный массив
int[,,] nums1 = new int[2, 3, 4];
```

#### [&uarr;](#0)  <a name="2_8_2">2) Простой перебор двумерного массива</a>
```c#
int[,] mas = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }, { 10, 11, 12 } };
foreach (int i in mas)
    Console.Write($"{i} ");
Console.WriteLine();
// result : "1 2 3 4 5 6 7 8 9 10 11 12 "
```

#### [&uarr;](#0)  <a name="2_8_3">3) Перебор двумерного массива по каждой строке таблицы</a>
* Метод GetUpperBound(dimension) - возвращает индекс последнего элемента в размерности `dimension`
```c#
int[,] mas1 = { { 1, 2, 3 } };
int[,] mas2 = { { 1, 2, 3 }, { 4, 5, 6 } };
int[,] mas3 = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
int[,] mas4 = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }, { 10, 11, 12 } };

int[,] mas5 = { { 1, 3 }, { 4 } }; // Ошибка внутренний индекс не может быть разным 

// Индексация идет с 0
int n;
n = mas1.GetUpperBound(0); // = 0 - индекс последнего элемента
n = mas2.GetUpperBound(0); // = 1   в первой(0) мерности
n = mas3.GetUpperBound(0); // = 2
n = mas4.GetUpperBound(0); // = 3

n = mas1.GetUpperBound(1); // = 2 - индекс последнего элемента
n = mas2.GetUpperBound(1); // = 2   во второй(1) мерности
n = mas3.GetUpperBound(1); // = 2
n = mas4.GetUpperBound(1); // = 2

n = mas1.GetUpperBound(2); // Ошибка массив не имеет 3 мерности

// ----------------- Конечный перебор -------------------------
// Находим количество строк и столбцов в двухмерном массиве
int[,] mas = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 }, { 10, 11, 12 } };

int rows = mas.GetUpperBound(0) + 1;
int columns = mas.GetUpperBound(1) + 1;

for(int i=0; i<rows; i++) {
	for(int j=0; j<columns; j++) {
		Console.Write($"{mas[i,j]} \t");
	}
	Console.WriteLine();
}
```

#### [&uarr;](#0)  <a name="2_8_4">4) Массив массивов (зубчатый массив)</a>
* Две группы квадратных скобок `[][]` указывают на массив массивов
* Длина указывается только в первых скобках `[3][]`
* Размерность каждого подмассива может не совпадать
```c#
int[][] nums1 = new int[3][];
nums1[0] = new int[2] { 1, 2 };          // выделяем память для первого подмассива
nums1[1] = new int[3] { 1, 2, 3 };       // выделяем память для второго подмассива
nums1[2] = new int[5] { 1, 2, 3, 4, 5 }; // выделяем память для третьего подмассива

// В качестве подмасивов могут быть многомерные массивы
int[][,] nums2 = new int[3][,] 
{
    new int[,] { {1,2}, {3,4} },
    new int[,] { {1,2}, {3,6} },
    new int[,] { {1,2}, {3,5}, {8, 13} } 
};

// Перебор зубчатого массива
foreach(int[] row in nums1) {
	foreach(int number in row) {
		// code..
	}
}
```

### [&uarr;](#0)  <a name="2_9">Методы</a>
```c#
[модификатор] тип_возвращаемого_значения название_метода ([параметры])
{
	// тело метода
	return возвращаемое_значение; // возврат и выход из метода
}
```
#### [&uarr;](#0)  <a name="2_9_1">1) Сокращенная запись методов</a>
```c#
// -------- 1 ----------
// ВМЕСТО
static void SayHello() {
	Console.WirteLine("Hello");
}
// БУДЕТ
static void SayHello() => Console.WriteLine("Hello");

// -------- 2 ----------
// ВМЕСТО
static string GetHello() {
	return "hello";
}
// БУДЕТ
static string GetHello() => "hello";
```

#### [&uarr;](#0)  <a name="2_9_2">2) Параметры методов</a>
```c#
// name - обязательный параметр
// age  - не обязательный параметр

static void Display(string name, int age=20) {
    Console.WriteLine($"Name: {name}  Age: {age}");
}

Display("Tom", 24); // Name: Tom  Age: 24
Display("Tom");     // Name: Tom  Age: 20
 
    
```

#### [&uarr;](#0)  <a name="2_9_3">3) Передача параметров (ref, out)</a>
* Стандартно простые параметры передаются по значению
* Передача параметров по ссылке требует модификатор ***ref***
```c#
// параметр x передается по ссылке (ref)
static void Addition(ref int x, int y) => x += y;

int x = 10;
int y = 15;
Addition(ref x, y);   // вызов метода
Console.WriteLine(x); // x = 25
```
* Чтобы сделать параметры выходными используется модификатор ***out***
```c#
static void Sum(int x, int y, out int a) => a = x + y;

int x = 10;
int z;
Sum(x, 15, out z); // z = 25

// Методы с модификатором out обязательно должны присваивать значение out параметрам
static void Sum(int x, int y, out int out1) => y = x + out1; // Ошибка значение для out не задано 
static void Sum(int x, int y, out int out1) => out1 = x + y; // Верно 
```

#### [&uarr;](#0)  <a name="2_9_4">4) Массив параметров (params)</a>
* Используя ключевое слово ***params***, можно передавать неопределенное кол-во пар-ов
```c#
static void Addition(params int[] integers) {...}

int[] array = new int[] {1,2,3,4,5};

Addition(1, 2, 3);    // верно
Addition(1, 2, 3, 4); // верно
Addition(array);      // верно
Addition();           // верно
```

### [&uarr;](#0)  <a name="2_10">Рекурсивные фун-ции</a>
* Функция вызывающая сама себя, стремящаяся к базовому варианту.
```c#
// функция факториала
static int Factorial(int x) {
    if (x == 0) {
        return 1;
    } else {
        return x * Factorial(x - 1);
    }
};

// функция фиббоначчи
static int Fibonachi(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    } else {
        return Fibonachi(n - 1) + Fibonachi(n - 2);
    }
}
```

### [&uarr;](#0)  <a name="2_11">Перечисления enum</a>
* ***enum*** - набор логически связанных констант
* Тип перечисление(default:int) указывается обязательно (byte, int, short, long)
* Стандартно каждому элементу присваивается целочисленное значение начиная с 0
```c#
// значения по умолчанию
enum Days : byte {
  Monday,    // = 0
  Tuesday,   // = 1
  Wednesday, // = 2
  Thursday,  // = 3
  Friday,    // = 4
  Saturday,  // = 5
  Sunday     // = 6
}

// значения явным образом
enum Operation
{ 
    Add = 2,      // = 2
    Subtract = 4, // = 4
    Multiply = 8, // = 8
    Divide = 16   // = 16
}

// использование
Operation operat;
operat = Operation.Add;
Console.WriteLine(operat);     // = "Add"
Console.WriteLine((int)operat) // = 2
```

### [&uarr;](#0)  <a name="2_12">Кортежи (c# v7.0)</a>
* Кортежи - удобный способ работы с набором значений
* Представляют набор значений, в круглых скобках
```c#
// создание кортежа c неявными типами
var tuple = (5, 10);

// обращение к кортежу
Console.WriteLine(tuple.Item1) // = 5
Console.WriteLine(tuple.Item2) // = 10
tuple.Item1 += 25;
Console.WriteLine(tuple.Item1) // = 30

// создание кортежа с явными типами
(int, int) tuple = (5, 10);
(string, int, double) person = ("Tom", 25, 81.236);

// создание кортежа с названиями полей
var tuple = (count:5, sum:10);
// обращение к полям
Console.WriteLine(tuple.count); // = 5
Console.WriteLine(tuple.sum);   // = 10

// кортеж без имени переменной в рамках метода или блока
var (name, age) = ("Tom", 23);
Console.WriteLine(name); // = "Tom"
Console.WriteLine(age);  // = 23

```

#### [&uarr;](#0)  <a name="2_12">1) Использование кортежей в функциях</a>
* Кортежи могут передоваться параметрами в метод
* Кортежи могут быть возвращаемым результатом функции
```c#
// передача кортежа в метод
private static void Tuple((string n, int a) tuple, int x) {
	string str = tuple.n;
	int num = tuple.a;
}

// возврат кортежа из функции
private static (int, int) GetValues() {
	var result = (1, 3);
	return result;
}
```

### [&uarr;](#3)  <a name="3">Классы (ООП)</a>
* Описанием ***объекта*** является ***класс***
* ***Объект*** представляет экземпляр ***класса***
* Вся функциональность класса выражена его :
	* ***Конструктором*** - `public Person() { name = "Tom"; age = 19; }`
	* ***Полями*** - `string name; int age;`
	* ***Свойствами*** - `public string Name { get; set; }`
	* ***Методами*** - `public getName() => this.name;`
	* ***Событиями*** - ???
* Класс не может содержать членов с именем, совпадающим с именем самого класса
```php
// ------------- Пример объявления класса Person + (поля, свойства, конструктор, метод)-------------
class Person {
  public string name; // поле name
  //public int age;   // поле age создается автоматически ниже

  public string Name {         // свойство для поля name
    get { return name };
    set { name = value }; 
  }
  public int Age { get; set; } // свойство для поля age (создает поле age)

  public Person() { name = "Неизвестно"; age = 18; } // конструктор

  public void GetInfo() { Console.WriteLine($"Имя: {name}  Возраст: {age}"); } // метод
}
```

#### [&uarr;](#3)  <a name="3_1"> Ключевое слово this в классах</a>
* Слово ***this*** обеспечивает доступ к текущему экземпляру класса
* Слово ***this*** в основном используется для :
	* ***1) Квалификации элементов***, скрытых одинаковыми именами
	* ***2) Передачи*** другим ***методам*** объекта в качестве параметра
	* ***3) Создания цепочки конструкторов (Constructor chaining)***
```php
// ------ 1) Квалификация элементов ------
// Конструктор
public SomeClass(string name, int age) {
	// присваиваем значение аргументов, полям класса
	this.name = name;
	this.age = age;
}

// ------ 2) Передача методам ------
// Метод1 внутри класса
public void method1() {
	// передача объекта класса в метод2 в виде параметра
	method2(this);
}
private void method2(SomeClass classObject) {
	// code..
}

// ------ 3) Создания цепочки конструкторов (Constructor chaining) ------
// --- Принцип работы Constructor chaining ---
// 1) Создание нескольких конструкторов
// 2) Вызов одного конструктора из другого : UserInfo() : this()

// class UserInfo; поля: Name, Family, Age
// создание "цепочки" конструкторов
public UserInfo() : this("None","None",0) {}
public UserInfo(UserInfo obj) : this(obj.Name, obj.Family, obj.Age) {}
public UserInfo(string Name, string Family, int Age) {
	this.Name = Name;
	this.Family = Family;
	this.Age = Age;
}

// Использование в программе
UserInfo ui1 = new UserInfo();
UserInfo ui2 = new UserInfo("Alex", "Green", 25);
UserInfo ui3 = new UserInfo(ui2);

// ЗАМЕЧАНИЕ : Начиная с версии .NET 4.0 цепочки можно заменить на необязательные аргументы

```

#### [&uarr;](#3)  <a name="3_2"> Инициализаторы объектов</a>
* Передача в `{}` скобках значений доступным полям и свойствам объекта
```php
class Person() {
	public string name;
	public int age;
	private int height;
}

Person p = new Person { name = "Tom", age = 32 }; // верно
Person p = new Person { name = "Tom", age = 32, height = 160 }; // Ошибка! height-недоступен

```

#### [&uarr;](#3)  <a name="3_3"> Организация памяти в .NET [Пример](http://stormy-lake-9982.herokuapp.com/assets/Stack%20and%20Heap-0714abf8c6b49cc57365a4aafbba510c.png)</a>
* Память делится на два типа
	* ***Стек*** - В стеке хранятся `типы значений` и `ссылки на адреса в куче`
	* ***Куча(heap)*** - В хипе хранятся `ссылочные типы` на которые указывают ссылки из ***Стека***
* Если из ***Стека*** удаляются все ссылки на объект, автоматический `сборщик мусора` удаляет объект из кучи и очищает память


#### [&uarr;](#3)  <a name="3_4"> Типы значений и ссылочные типы</a>
* Типы значений :
	* Целочисленные типы (`byte, sbyte, char, short, ushort, int, uint, long, ulong`)
	* Типы с плавающей запятой (float, double)
	* decimal
	* bool
	* enum
	* Структуры (struct)

* Ссылочные типы :
	* Object
	* string
	* Классы (class)
	* Интерфейсы (interface)
	* Делегаты (delegate)

#### [&uarr;](#3)  <a name="3_5"> Передача параметров по значению и по ссылке (***ref***)</a>
* Передача параметров :
	* ***По значению*** :
		* Передается копия ссылки на объект.
		* Изменяет поля и свойства объекта, но не сам объект.
	* ***По ссылке***(ключевое слово ***ref***) :
		* Передается сама ссылка на объект.
		* Изменяет как поля и свойства, так и сам объект.
```php
Person p = new Person { name = "Tom", age = 23 };

// ------ 1) Передача параметров по значению ------
ChangePerson(p);

public void ChangePerson(Person person) {
	person.name = "Alice";                           // Изменит в p.name Tom на Alice
	person = new Person { name = "Bill", age = 45 }; // Не изменит в p ничего
}

// ------ 2) Передача параметров по ссылке ------
ChangePerson(ref p);

public void ChangePerson(ref Person person) {
	person.name = "Alice";                           // Изменит в p.name Tom на Alice
	person = new Person { name = "Bill", age = 45 }; // Изменит весь объект p
}
```

#### [&uarr;](#3)  <a name="3_6"> Модификаторы доступа (допустимая область видимости)</a>
* ***Пространства имен*** (`namespace`) не имеют ограничений доступа
* В C# применяются модификаторы :
	* ***public*** : Неограниченный доступ
	* ***private*** : Доступ ограничен содержащим типом
	* ***protected*** : Доступен из любого места в текущем классе или в производных классах
	* ***internal*** : Доступ ограничен текущей сборкой
	* ***protected internal*** : Доступен из текущей сборки и из производных классов
	* ***private protected*** (C# v7.2) : Доступен в текущем классе или производных, той же сборки
* Классы объявленные без модификатора по умолчанию имеют доступ ***internal***
* Классы созданные в `пространстве имен` и не вложенные в другие классы могут быть либо ***public***, либо ***internal***

<table>
	<tr>
		<th>Члены типа</th>
		<th>Доступность по умолчанию</th>
		<th>Варианты доступности</th>
	</tr>
	<tr>
		<td>enum</td>
		<td>public</td>
		<td>Нет</td>
	</tr>
	<tr>
		<td>class</td>
		<td>private</td>
		<td>Все</td>
	</tr>
	<tr>
		<td>interface</td>
		<td>public</td>
		<td>Нет</td>
	</tr>
	<tr>
		<td>struct</td>
		<td>private</td>
		<td>public, internal, private</td>
	</tr>
</table>

#### [&uarr;](#3)  <a name="3_7"> Свойства (специальные методы доступа)</a>
* По сути синтаксический сахар уменьшающий количество ручного кода
* Суть действия :
```php
// При создании свойства Speed
class Example {
  public int Speed { get; private set; } // создание свойства
}

// По факту получаем
class Example {
  private int _speed;

  public int get_Speed() {
    return _speed;
  }

  private void set_Speed() {
    _speed = value;
  }
}
```
* Доступ к полям класса - `get; set;`
```php
class Person {
  private string name;
  public string Name {
    get { return name; }
    set { name = value; } // value представляет передаваемое значение
  }
}
Person p = new Person();
p.Name = "Tom";          // вызывает Name.set
string perName = p.Name; // вызывает Name.get
```
* Доступ к полю может быть ограничен одним из методов `get` или `set`
* Если у свойства нет метода `set` то задать значение можно только в конструкторе класса
```php
// --- только метод get ---
public string Name {   // поле name без метода set
  get { return name; } // можно получить, нельзя изменить
}
// --- только метод set ---
public int Age {       // поле age без метода get
  set { age = value; } // можно изменить, нельзя получить
}
```
* Модификатор доступа(МД) для ***свойства***
	* Можно установить только когда есть и `get` и `set`
	* Только один блок `get` или `set` может иметь МД, но не оба сразу
	* МД блока `get` или `set` должен быть более ограничивающим, чем МД ***свойства***
* Сокращенная запись свойств :
```php
private string name;

// эквивалентно public string Name { get { return name; } }
public string Name => name;
```

#### [&uarr;](#3)  <a name="3_8"> Автоматические свойства(АС)</a>
* Сокращенное объявление АС :
	* Сокращает запись объявления свойств
	* Убирает необходимость объявления одноименных полей
```php
class Person {
  public string Name { get; set; } // АС Name + создание поля (string)name
  public int Age { get; set; }     // АС Age  + создание поля (int)age

  public Person(string name, int age) {
    Name = name;
    Age = age;
  }
}
```
* АС можно присвоить значения по умолчанию(инициализация АС) :
```php
public string Name { get; set; } = "Tom"; // name = "Tom"
public int Age { get; set; } = 23;        // age = 23
```
* АС с МД :
```php
public string Name { get; private set; }
```
* АС без блока set :
```php
public string Name { get; } = "Tom";
```

#### [&uarr;](#3)  <a name="3_9"> Перегрузка методов</a>
* Перегрузка - методы с разной сигнатурой :
  * Количество параметров
  * Типы параметров
  * Порядок параметров
  * Модификаторы параметров
```php
public void Add(int a, int b) {}                        // сигнатура : Add(int, int)
public void Add(int a, int b, int c) {}                 // сигнатура : Add(int, int, int)
public int Add(int a, int b, int c, int d) {return int} // сигнатура : Add(int, int, int, int)
public void Add(double a, double b) {}                  // сигнатура : Add(double, double)
public void Add(ref int a, ref int b) {}                // сигнатура : Add(ref int, ref int)
```

#### [&uarr;](#3)  <a name="3_10"> Модификатор static (статические элементы СЭ)</a>
* Статические поля, методы и свойства относятся ко всему классу
* Для обращения к СЭ не нужно создавать экземпляр класса.
* Для СЭ будет создаваться участок в памяти, общий для всех объектов класса. [Рисунок](https://metanit.com/sharp/tutorial/pics/static.png)
* Память для СЭ выделяется, даже если не создано ни одного объекта
* СЭ должны быть :
  * ***Переменные*** и ***свойства***, которые хранят состояние, общее для всех объектов класса
  * ***Методы***, которые определяют общее для всех объектов поведение.
* Статические ***методы*** могут обращаться только к СЭ класса.
```php
static int count1 = 0;
int count2 = 0;

public static int getCount() {
  count1 =+ count2; // Ошибка, нельзя обратиться к count2 внутри getCount(static)
  return count1;    // Верно, можно обратиться к count1(static)
}
```

* ***Статический конструктор*** класса : `static className() {...}`
  * Называется ***конструктором типа***
  * Не может иметь модификаторы доступа и не принимает параметры
  * Не использует слово ***this*** и обращается только к СЭ
  * Нельзя вызвать вручную.
  * Выполняется автоматически, при первом использовании объектов или СЭ класса
  * Используется для :
    * Инициализации статических данных(СЭ)
    * Выполнения действий, которые нужно выполнить один раз

* Статический классы : `static className {...}`
  * Объявляются с модификатором ***static***
  * Могут содержать только СЭ

#### [&uarr;](#3)  <a name="3_11"> Константы и поля для чтения (const, readonly)</a>
* Константы : (***const***)
  * Перед типом данных ключевое слово ***const***
  * Инициализация при определении
  * Значение не может быть изменено
  * Неявно является ***Статическим полем***
```php
const double PI = 3.14; // Верное объявление константы
const double E;         // Ошибка, нельзя создавать константу без значения
PI = 5.66;              // Ошибка, нельзя изменять константы
double pi = Math.PI;    // Обращение к константе идёт через имя класса (static)                
```
* Поля для чтения : (***readonly***)
  * Перед типом данных слово ***readonly***
  * Инициализация при создании внутри класса
  * Изменение в конструкторе
  * Могут быть статическими(static)
```php
public readonly int value = 23;
```

#### [&uarr;](#3)  <a name="3_12"> Перегрузка операторов (`- + < > ...`)</a>
* Перегружаемые операторы :
  * Унарные `+, -, !, ~, ++, --`
  * Бинарные `+, -, *, /, %`
  * Сравнения `==, !=, <, >, <=, >=`
  * Логические `&&, ||`
  * Присваивания `+=, -=, *=, /=, %=`
  * Операторы `true, false`
* Методы должны иметь модификатор ***public static***
* Вместо названия метода ключевое слово ***operator***, затем сам оператор
* Унарные операторы принимают 1 параметр
* Бинарные операторы принимают 2 параметра
* Один из параметров должен иметь тип определяемого класса или структуры
```php
// общий вид
public static возвращаемый_тип operator оператор(параметры) {...}

// примеры
public static Counter operator +(Counter c1, Counter c2) {...return new Counter...}
public static bool operator >(Counter c1, Counter c2){...return bool...}
public static bool operator <(Counter c1, Counter c2){...return bool...}

// использование
Counter c1 = new Counter();
Counter c2 = new Counter();
Counter c3 = c1 + c2;
bool biger = c3 > c2;
```
* При перегрузке не должны изменяться передаваемые объекты
* Возвращается всегда новый объект, с измененным значением от старого
```php
public static Counter operator ++(Counter c1) {c1.Value += 10; return c1; } // НЕВЕРНО
public static Counter operator --(Counter c1) {return new Counter { Value = c1.Value - 10 }; } // ВЕРНО
```
* Операции инкремента и декремента задаются сразу для префиксного и постфиксного изменения

* При необходимости использования объекта типа в качестве условия :
  * Переопределяются операторы `true, false`
```php
// переопределение
public static bool operator true(Counter c1) { return c1.Value != 0; }
public static bool operator false(Counter c1) { return c1.Value == 0; }

// использование
Counter counter = new Counter();
if(counter) {...}
```

#### [&uarr;](#3)  <a name="3_13"> Значение Null (отсутствие значения)</a>
* Значение ***null*** могут принимать только переменные ссылочных типов
* Значение ***null*** является значением по умолчанию
```php
object o = null;
string s1 = null;
string s2;  // также равно null
```
* Оператор null-объединения (***??***) :
  * Для переменных ссылочного типа
  * Возвращает левый операнд, если он не равен ***null***, иначе возвращает правый операнд
  * Левый операнд должен быть ссылочного типа
```php
object x = null;
object y = x ?? 100; // = 100, х равен null
object z = y ?? 44;  // = 100, y не равен null
``` 
* Оператор условного null (***?.***)
  * Проверяет равен ли объект значению ***null***
```php
string companyName = user?.Phone; // проверяет равен ли Phone null и возвращает значение либо null
string companyName = user?.Phone?.Company?.Name; // проверка на нескольких уровнях в глубину
```

#### [&uarr;](#3)  <a name="3_14"> Индексаторы</a>
* Позволяют индексировать объекты и обращаться к ним по индексу
  * Работа с объектами как с массивами
  * Индексатор не имеет названия
  * Указывается ключевое слово ***this***
  * Должен иметь как минимум один параметр(индекс)
```php
// общий вид
возвращаемый_тип this [Тип параметр1, ...] {
  get {...}
  set {...}
}

// пример
class Person
{
  public string Name { get; set; }
}
class People
{
  Person[] data;
  public People()
  {
      data = new Person[5];
  }
  // индексатор
  public Person this[int index]
  {
      get
      {
          return data[index];
      }
      set
      {
          data[index] = value;
      }
  }
}

// использование
People people = new People();
people[0] = new Person { Name = "Tom" };
people[1] = new Person { Name = "Bob" };

Person tom = people[0];
Console.WriteLine(tom?.Name);
```
* Перегрузка индексаторов
```php
public Person this[int index] {...}
public Person this[string name] {...}
```

#### [&uarr;](#3)  <a name="3_15"> Наследование (inhertiance)</a>
* Все классы наследуются от базового класса Object
  * Методы : `ToString(), Equals(), GetHashCode(), GetType()`
* Наследуются все свойства, методы, поля без модификатора ***private***
* Конструктор базового класса не наследуется
```php
// базовый класс
class Person {

}

// класс наследник от Person
class Employee : Person {

}

Person p = new Employee(); // Верно

```
* Множественное наследование не поддерживается
* Тип доступа(public) может быть либо такой же, либо более строгий
* Модификатор ***sealed*** запрещает наследование
* Статические классы не наследуются
```php
sealed class Admin {...} // нельзя наследоваться от класса Admin
```

#### [&uarr;](#3)  <a name="3_16"> Ключевое слово ***base***</a>
* При помощи ***base*** мы обращаемся к конструктору базового класса
* Сначала выполняется конструктор родителя, затем наследника
* ***ВАЖНО*** : всегда задавать базовый конструктор через слово ***base***
```php
// Person - базовый класс
public Person(string name) {
  Name = name;
}

// Employee - наследник от Person
public Employee(string name, string company) : base(name) {
  // сначала выполнится код : Name = name; из базового класса
  Company = company;
}
```
* При помощи ***base***, также можно обращаться к другим членам базового класса
```php
// Person - базовый класс
public virtual void Display() {...} // виртуальный метод Display

// Employee - наследник от базового класса
public override void Display() {    // переопределенный метод Display
  base.Display(); // обращение к коду базового класса
  ...;            // дополнительный код
}
```

#### [&uarr;](#3)  <a name="3_17"> Преобразование типов (object)</a>
* Простая схема наследования : [Рисунок](https://metanit.com/sharp/tutorial/pics/3.12.png)
* Указывают на один и тот же объект
* Доступна разная часть функционала
* Более общему классу не доступны поля и методы более специфичного класса
* Восходящее (Upcasting) :
```php
Employee emp = new Employee();
Person person = emp; // восходящее преобразование от Employee к Person 
```
* Нисходящее (Downcasting) :
  * Необходимо явное преобразование, с указанием нужного типа в скобках 
```php
Employee emp1 = person;           // Ошибка, нужно явное преобразование
Employee emp2 = (Employee)person; // Верно, преобразование от Person к Employee
```

##### [&uarr;](#3)  <a name="3_17_1"> Способы преобразования типов :</a>
* Использование ключевого слова ***as*** :
  * Не выбрасывает исключение
  * При неудаче возвращает значение ***null***
```php
Person person = new Person("Tom");
Employee emp = person as Employee; // вернет null при неудаче
```
* Использование исключения InvalidCastException
```php
try{}catch(InvalidCastException ex){} // выбросит ошибку при неудаче
```
* Проверка допустимости преобразования через слово ***is***(true/false) 
```php
Person person = new Person("Tom");
if(person is Employee) { // проверка перед преобразованием через is
  Employee emp = (Employee)person;
}
```

#### [&uarr;](#3)  <a name="3_18"> Перегрузка операций преобразования типов</a>
* Определяет логику преобразования одних типов в другие
* Оператор преобразования должен либо принимать, либо возвращать тип своего объекта
```php
public static implicit|explicit operator Тип_в_который_надо_преобразовать(исходный_тип param){}
```
* ***explicit*** - если преобразование явное(приведение типов)
* ***implicit*** - есди преобразование неявное(без скобок с типом)
```php
// пример
class Counter {
  public int Seconds { get; set; }
  public static implicit operator Counter(int x) {
    return new Counter { Seconds = x };
  }
  public static explicit operator int(Counter counter) {
    return counter.Seconds;
  }
}

// использование
Counter counter1 = new Counter { seconds = 23 };

int x = (int)counter1; // x = 23
Counter counter2 = x;  // counter2.seconds = 23
```

#### [&uarr;](#3)  <a name="3_19"> Полиморфизм. Виртуальные методы и свойства (***virtual***)</a>
* Полиморфизм - когда один метод может иметь несколько различных реализаций, через наследование.
* ***virtual*** - Это методы и свойства, которые нужно переопределять при наследовании
* В родительком классе используют ключевое слово ***virtual***
* В дочернем классе используют ключевое слово ***override***
* Набор параметров ***обязан*** совпадать (родидель/наследник)
* Модификатор доступа ***обязан*** совпадать (родидель/наследник)
* ***Статический метод*** не может быть виртуальным

```php
// базовый класс
class Person {
  public virtual void Display(string name, int age) {  // виртуальный метод
    ... // базовый код метода
  }
}
// наследник от Person
class Client : Person {
  public override void Display(string name, int age) { // переопределение виртуального метода
    ... // переопределенный код метода
  }
}
```

* Переопределение свойств
```php
// базовый класс
class Person {
  public virtual int Sum { get; set; } // виртуальное свойство
}
// наследник от Person
class Client : Person {
  public override int Sum {            // переопределенное свойство
    get {...} ; // новый код для get 
    set {...} ; // новый код для set
  }
}
```
* Запрет переопределения методов и свойств, через модификатор ***sealed***
* Запрет может быть только для ***override*** свойств
```php
public override sealed void Display() {...}
```

#### [&uarr;](#3)  <a name="3_20"> Сокрытие (shadowing/hiding)</a>
* Ещё один способ наследования методов
* ***Отличие от переопределения*** : возможность менять элементы без модификатора ***virtual***
* Также можно переопределять переменные и константы
* Используется ключевое слово ***new***
```php
// базовый класс
class Person {
  public readonly int x = 10;     // базовая переменная x
  public const int CON = 5;       // базовая константа CON
  public void Display() {...}     // базовый метод
}
// класс наследник
class Client : Person {
  public new readonly int x = 20; // переопределенная x
  public new const int CON = 25;  // переопределенная CON
  public new void Display() {     // переопределенный метод
    base.Display();  // обращение к коду базового класса 
    ...
  }
}
```

#### [&uarr;](#3)  <a name="3_21"> Абстрактные классы</a>
* Цель : создание класса с общими методами и свойствами, для последующего наследования 
* Используется ключевое слово ***abstract***
* Может содержать как ***абстрактные*** члены, так и ***виртуальные***
* Нельзя создавать объекты
```php
// абстрактный класс
abstract class Human {...}
// класс наследник
class Client : Human {...}

Human human = new Human();   // Ошибка нельзя создать объект абстрактного класса
Human client = new Client(); // А так можно делать
```

#### [&uarr;](#3)  <a name="3_22"> Абстрактные члены классов</a>
* Не могут иметь модификатор ***private***
* ***Производный*** класс(наследник) обязан переопределить и реализовать все абстрактные элементы
* При переопределении элементы объявляется с модификатором ***override***
* Если есть абстрактный элемент, сам класс тоже должен быть с модификатором ***abstract***
* Абстрактными могут быть :
  * Методы
  * Свойства
  * Индексаторы
  * События
```php
abstract class Person {
  public abstract void Display();           // абстрактный метод
  public abstract string Name { get; set; } // абстрактное свойство
}

// Производный класс может не реализовывать абстрактные члены родительского если сам тоже = abstract
abstract class Manager : Person {}
```

#### [&uarr;](#3)  <a name="3_23"> Класс System.Object и его методы</a>
* ***ToString()*** - возвращает стоковое представление данного объекта
  * Для базовых типов просто выводится строковое значение
  * Для классов полное название, пространство имен(можно переопределить)
```php
public override string ToString() {
  base.ToString(); // базовая логика метода
  ...              // дополнительная логика
};
```
* ***GetHashCode*** - возвращает числовое значение, данного объекта или его хэш-код.
  * По данному значению можно сравнивать объекты.
  * Для классов можно переопределить
```php
public override int GetHashCode() {...}
```
* ***GetType*** - возвращает тип данного объекта
  * Возвращает объект Type
  * Не переопределяется
```php
Person person = new Person { Name = "Tom" };
person.GetType(); // = Person
```
* ***Equals*** - позволяет сравнить два объекта на равенство
  * Принимает в параметр объект для сравнения
  * Можно переопределить
```php
public override bool Equals(object obj) {...}
``` 

#### [&uarr;](#3)  <a name="3_24"> Обобщения .NET v2.0 (`className<T>`)</a>
* Позволяют повторно использовать код, между различными типами.
* Решает проблему [упаковки(boxing) и распаковки(unboxing)](https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/types/boxing-and-unboxing)
  * Упаковка - преобразование объекта значимого типа(int) к типу object(System.Object) из стека в кучу
  * Распаковка - обратная операция из object в значимый тип(int) из кучи в стек
  * Обе операции снижают производительность
* Решает проблему безопасности типов
  * Без обобщения мы можем не знать к какому типу нужно приводить - исключение(InvalidCastException)
  * С обобщением мы сразу же получим ошибку компиляции
* Тип ***Т*** - ***универсальный параметр*** (можно подставить любой другой тип)
```php
// пример обобщенного типа
class Account<T> {          // T - тип используемый в классе
  public T Id { get; set; } // T - тип используемый в Id
  public int Sum { get; set; }
}

// использование
Account<int> acc1 = new Account<int> { Sum = 5000 };
Account<string> acc2 = new Account<string> { Sum = 4000 };
```

##### [&uarr;](#3)  <a name="3_24_1"> Значение по умолчанию (***default(T)***)</a>
  * Присваивает :
    * Cсылочным типам - значение ***null***
    * Типам значений(int) - значение ***0***
```php
class Account<T> {
  T id = default(T);
}
```

##### [&uarr;](#3)  <a name="3_24_2"> Статические поля обобщенных классов</a>
* При типизации обобщенного класса будет создаваться свой набор статических членов
```php
// обобщенный класс с типом Т
class Account<T> {
  public static T session;
}

// использование статических полей
Account<int> acc1 = new Account<int>();
Account<int>.session = 553;       // первая статическая переменная session
Account<string> acc2 = new Account<string>();
Account<string>.session = "2314"; // вторая статическая переменная session
// Account<int>.session != Account<string>.session (две разные статические переменные)
```

##### [&uarr;](#3)  <a name="3_24_3"> Использование нескольких универсальных параметров</a>
```php
// обобщенный класс с типами U, V
class Transaction<U, V> {
  public U FromAccount { get; set; }
  public V Code { get; set; }
}

// использование
Transaction<int, string> tran1 = new Transaction<int, string>();
Transaction<Account<int>, string> tran2 = new Transaction<Account<int>, string>();
```

##### [&uarr;](#3)  <a name="3_24_4"> Обобщенные методы</a>
* Методы точно также могут быть обобщенными
```php
// обобщенный метод
public static void Swap<T> (ref T x, ref T y) {
  T temp = x;
  x = y;
  y = temp;
}

// использование обобщенного метода
int x = 7;
int y = 25;
Swap<int>(ref x, ref y); // x = 25, y = 7

string s1 = "hello";
string s2 = "bye";
Swap<string>(ref s1, ref s2); // s1 = bye, s2 = hello
```

#### [&uarr;](#3)  <a name="3_25">Ограничения обобщений (ОО)</a>
* Через ОО можно конкретизировать тип `Т`
* Синтаксис:
```php
class Transaction<T> where T : Account {...}
```
* В ОО используются типы :
  * Классы
  * Интерфейсы
  * Универсальные параметры :
    * class
    * struct
    * new() - тип имеющий public конструктор без параметров
```php
class Account<T> where T : struct {...} // только структуры
class Account<T> where T : class  {...} // только классы
class Account<T> where T : new()  {...} // классы и структуры с public конструктором без параметров

```
* При указании класса в ОО, `T` может быть либо этим классом, либо его наследниками
```php
class Account {...}
class DepositAcc : Account {...}
class DemandAcc  : Account {...}
class Transaction<T> where T : Account {...}

Transaction<Account>    tran1 = new Transaction<Account>;      // верно
Transaction<DepositAcc> tran2 = new Transaction<DepositAcc>;   // тоже верно
Transaction<DemandAcc>  tran3 = new Transaction<DemandAcc>;    // тоже верно
```
* В ОО можно использовать обобщенный класс
```php
class Transaction<T> where T : Account<int> {...}
Transaction<Account<int>>    tran1 = new Transaction<Account<int>>;    // верно
Transaction<Account<string>> tran1 = new Transaction<Account<string>>; // ошибка
```
* При нескольких ограничениях за раз, должен быть порядок следования :
  1. Название класса, class, struct (одновременно только одно)
  2. Название интерфейса
  3. new()
```php
class Transaction<T> where T : Person, IAccount, new()
```
* Несколько универсальных параметров в ОО
```php
class Transaction<U, V> 
            where U : Account<int> 
            where V : struct {
    ...
}
```
* ОО для методов
```php
public static void Transact<T>(T acc1, T acc2, int sum) where T : Account {...}
```

#### [&uarr;](#3)  <a name="3_26">Наследование обобщенных типов(ОТ) </a>
* Один ОТ может наследоваться от другого ОТ
* Варианты наследования :
  * Вариант 1: Создание класса-наследника с тем же типом что и базовый
  * Вариант 2: Создание необобщенного класса-наследника(для базового класса явно определить тип)
  * Вариант 3: Типизация отличным от базового параметра типом(для базового класса явно определить тип)
```php
//--------- Вариант 1
class Account<T> {...}
class Account2<T> : Account<T> {...}

// применение
Account<string> acc1 = new Account<string>();
Account<int>    acc2 = new Account2<int>();
Account2<int>   acc3 = new Account2<int>();

//--------- Вариант 2
class StringAccount : Account<string> {
  public StringAccount(string id) : base(id) {...}
}

// применение
StringAccount   acc4 = new StringAccount("453"); // верно
Account<string> acc5 = new StringAccount("664"); // верно
Account<int>    acc6 = new StringAccount("664"); // ошибка

//--------- Ваоиант 3
class IntAccount<T> : Account<int> {...} // тип Т может не совпадать с int

// применение
IntAccount<string> acc7 = new IntAccount<string>();
Account<int> acc8 = new IntAccount<long>();
```

##### [&uarr;](#3)  <a name="3_26_1">Сочетание своих обобщенных параметров и базового класса</a>
```php
class MixedAccount<T, K> : Account<T>
            where T : struct {...}

// применение
MixedAccount<string, int> acc9 = new MixedAccount<string, int>();
Account<string> acc10 = MixedAccount<string, int>();
```

### [&uarr;](#4)  <a name="4">Обработка исключений</a>

#### [&uarr;](#4)  <a name="4_1">Конструкция try...catch...finally</a>
* ***Исключения*** - Трудно отслеживаемые ошибки, с аварийным завершением программы
* Блок ***try...catch...finally*** - для обработки исключений(без аварийного завершения)
* Возникновение исключения в программе :
  * Нет блока ***try/catch*** : ***Аварийное завершение программы***
  * Есть блок ***try/catch*** : ***Попытка обработать исключение***
* Блок ***finally*** не обязательный
```php
try {
  ...
} catch (Exception ex) {
  ...
} finally {
  ...
}
```
* Порядок выполнения блока (try/catch) :
  * Сначала блок try
  * Если есть исключение
    * Поиск подходящего блока ***catch*** с нужной ошибкой
      * Нужный блок ***catch*** найден : ***выполнение блока***
      * Нужный блок ***catch*** не найден : ***аварийное завершение работы***
    * Затем блок ***finally*** - если есть
  * Если нет исключений
    * Блок ***finally*** - если есть
* Блоков ***catch*** может быть несколько под разные исключения
* Запись блоков ***catch*** должна быть от частных случаев к более общим
* С точки зрения производительности ***try...catch*** лучше заменять на условную конструкцию(***if...else***)

#### [&uarr;](#4)  <a name="4_2">Блок ***catch*** и фильтры исключений</a>
* ***catch*** имеет разные формы :
```php
catch {...}                   // обрабатывает любое исключение
catch (тип_исключения) {...}  // только исключения по указанному типу
catch (Exception excep)       // в excep содержится вся информация об исключении
```

##### [&uarr;](#4)  <a name="4_2_1">Фильтры исключений</a>
* Обработка исключений в определенных условиях
* Синтаксис условия `catch when(условие)`
```php
try {
  ...
} catch (DivideByZeroException) when (y==0 && x==0) {
  ...
} catch (DivideByZeroException ex) {
  ...
}
```

#### [&uarr;](#4)  <a name="4_3">Типы исключений. Класс Exception</a>
* ***Exception*** - базовый тип для всех исключений
* ***Exception*** свойства :
  * ***InnerException*** : причина исключения
  * ***Message*** : текст ошибки
  * ***Source*** : имя объекта или сборки, вызвавшего исключение
  * ***StackTrace*** : строковое представление стека вызова
  * ***TargetSite*** : метод, в котором было вызвано исплючение
* Виды исключений :
  * ***DivideByZeroException*** : деление на ноль
  * ***ArgumentOutOfRangeException*** : аргумент вне диапозона допустимых значений
  * ***IndexOutOfRangeException*** : индекс массива вне диапозона допустимых значений
  * ***InvalidCastException*** : недопустимое преобразование типов
  * ***NullReferenceException*** : обращение к объекту со значением ***null***

#### [&uarr;](#4)  <a name="4_4">Создание классов исключений</a>
* Наследование от базового класса ***Exception***
* Простой вариант ручного вызова исключения
```php
if(value < 18) {
  // исключение где Message = "Меньще 18 нельзя"
  throw new Exception("Меньще 18 нельзя"); // вызовет общее исключение
}
```
* Создание класса исключения :
```php
class PersonException : Exception {
  public PersonException(string message) : base(message) {
    ...
  }
}

// использование
if(value < 18) {
  throw new PersonException("Меньше 18 нельзя");
}
```
* Наследование от других ошибок :
```php
// наследование от производного класса
class PersonException : ArgumentException {
  // дополнительное поле val для исключения
  public PersonException(string message, int val) : base(message) {

  }
}

// использование
if(value < 18) {
  throw new PersonException("Меньше 18 нельзя", value);
}
```

#### [&uarr;](#4)  <a name="4_5">Поиск блока catch при обработке исключения</a>
* При отсутствии нужного блока ***catch*** - происходит поиск нужного обработчика исключения в стеке вызовов.
* Пример для изучения : 
```c#
class Program {
  static void Main(string[] args)
  {
    try
    {
        TestClass.Method1();
    }
    catch (DivideByZeroException ex)
    {
        Console.WriteLine($"Catch в Main : {ex.Message}");
    }
    finally
    {
        Console.WriteLine("Блок finally в Main");
    }
    Console.WriteLine("Конец метода Main");
    Console.Read();
  }
}
class TestClass
{
  public static void Method1()
  {
    try
    {
        Method2();
    }
    catch (IndexOutOfRangeException ex)
    {
        Console.WriteLine($"Catch в Method1 : {ex.Message}");
    }
    finally
    {
        Console.WriteLine("Блок finally в Method1");
    }
    Console.WriteLine("Конец метода Method1");
  }
  static void Method2()
  {
    try
    {
        int x = 8;
        int y = x / 0;
    }
    finally
    {
        Console.WriteLine("Блок finally в Method2");
    }
    Console.WriteLine("Конец метода Method2");
  }
}

//--------- Порядок выполнения кода ---------
// 1) Вызов Method1, вызов Method2, генерация исключения DivideByZeroException
// 2) Поиск блока catch - блок не найдет
// 3) Спуск в стеке в метод Method1, поиск блока catch - блок не найдет
// 4) Спуск в стеке в метод Main, поиск блока catch - блок НАЙДЕН
// 5) Блок catch не выполняется сразу, система поднимается в метод Method2
// 6) Выполнение блока finally в методе Method2, сразу переход в Method1
// 7) Выполнение блока finally в методе Method1, сразу переход в Main
// 8) Выполнение блока catch в Main, выполнение блока finally в Main
// 9) Далее код идущий после блока try...catch в Main
//10) Код идущий после try...catch в методах Method1, Method2 не выполняется

//--------- Консольный вывод программы ---------
// Блок finally в Method2
// Блок finally в Method1
// Catch в Main: Попытка деления на нуль.
// Блок finally в Main
// Конец метода Main
```

#### [&uarr;](#4)  <a name="4_6">Генерация исключения и оператор throw</a>
* Генерация исключений вручную : ***throw***
```c#
throw new Exception("Text");
```
* После ***throw*** указывается объект исключения с параметрами об ошибке
* Доступно использование любого типа исключений :
```c#
throw new NullReferenceException("Text");
throw new IndexOutOfRangeException("Text");
throw new ArgumentOutOfRangeException("Text");
throw new DivideByZeroException("Text");
```
* Использование ***throw*** без объекта :
  * Только внутри блока ***catch***
  * Вызывает блок ***catch*** внешней конструкции
```c#
try
{
  try
  {
    ...    // при ошибке здесь
  }
  catch
  {
    throw; // переход отсюда
  }
}
catch (Exception ex)
{
  ...      // сюда
}
```

### [&uarr;](#5)  <a name="5">Интерфейсы</a>

#### [&uarr;](#5)  <a name="5_1">Введение в интерфейсы</a>
* Ключевое слово ***interface***
* ***Ссылочный тип***
* Определяет набор методов и свойств
* ***Ничего*** не реализует
* Реализуются дальше в классах и структурах
* Названия начинаются с ***I*** : `IMovable, IAction, IAccount, IClient`
* Элементы не имеют модификаторов доступа (по факту везде ***public***)
* Может определять сущности :
  * ***Методы***
  * ***Свойства***
  * ***Индексаторы***
  * ***События***
* Не может определять :
  * ***Статические члены***
  * ***Переменные***
  * ***Константы***
```c#
interface IMovable {
  void Move();
}

// применение интерфейса в классе
class Person : IMovable {
  public void Move() {
    Console.WriteLine("Человек идет");
  }
}

// применение интерфейса в структуре
struct Car : IMovable {
  public void Move() {
    Console.WriteLine("Машина едет");
  }
}
```
* Все элементы интерфейса должны быть обязательно реализованы (только с ***public***)
* Если класс абстрактный то можно переложить обязанность реализации на следующих потомков
* Если наследнику нужен другой модификатор, интерфес ***не подходит***
* При наследовании одновременно от интерфейса и базового класса методы могут быть от базового класса
```c#
interface IAction {
  void Move();
}

class BaseAction {
  public void Move() {...}
}

class HeroAction : BaseAction, IAction {
  // Реализация метода Move() не указана и это не ошибка, т.к берется Move() от BaseAction
}
```

#### [&uarr;](#5)  <a name="5_1_1">Множественная реализация интерфейсов</a>
* C# не поддерживает множественное наследование
* Может реализовать сразу несколько интерфейсов
```c#
class myClass : Interface1, Interface2, Interface3 {
  ...
}
```

#### [&uarr;](#5)  <a name="5_1_2">Интерфейсы в преобразованиях типов</a>
* Преобразования типов характерны и для интерфейсов
* Преобразование от класса к его интерфейсу, выполняется автоматически
* Преобразование от интерфейса к классу, выполняется с обязательным приведением типа
```c#
interface IAccount {
  int CurrentSum { get; }  // Текущая сумма на счету
  void Put(int sum);      // Положить деньги на счет
  void Withdraw(int sum); // Взять со счета
} interface IClient {
  string Name { get; set; }
}
class Client : IAccount, IClient {
  int _sum; // Переменная для хранения суммы
  public string Name { get; set; }
  public Client(string name, int sum) {
    Name = name;
    _sum = sum;
  }

  public int CurrentSum { get { return _sum; } }
  public void Put(int sum) {  _sum += sum; }
  public void Withdraw(int sum) {
    if (_sum >= sum) {
      _sum -= sum;
    }
  }
}

// Client реализует IAccount, переменная типа IAccount может хранить ссылку на Client
// Все объекты Client является объектами IAccount

IAccount account = new Client("Tom", 200);
account.Put(200);
Console.WriteLine(account.CurrentSum); // 400

// Не все объекты IAccount являются объектами Client, необходимо явное приведение
Client client = (Client)account;

// Интерфейс IAccount не имеет свойства Name, необходимо явное приведение
string clientName = ((Client)account).Name;
```

#### [&uarr;](#5)  <a name="5_2">Наследование интерфейсов</a>
* ***interface*** не может иметь модификатор ***sealed***
* ***interface*** может наследоваться также как классы
```java
interface IAction {
  void Move();
}
interface IRunAction : IAction {
  void Run();
}
class BaseAction : IRunAction {
  public void Move() {...}
  public void Run() {...}
}
```
* Класс должен реализовать методы всех унаследованных интерфейсов
* Можно применять модификатор ***abstract***
* Можно использовать сокрытие методов (***new***)
```java
interface IAction {
  void Move();
}
interface IRunAction : IAction {
  new void Move();
}
```
* Модификаторы доступа работают также как у классов. По умолчанию ***internal***

#### [&uarr;](#5)  <a name="5_2_1">Изменение реализации интерфейсов в производных классах</a>
* Вариант 1 - переопределение виртуальных/абстрактных методов
```java
interface IAction {
  void Move();
}
class BaseAction : IAction {
  public virtual void Move() {...}
}
class HeroAction : BaseAction {
  public override void Move() {...}
}
// применение
BaseAction action1 = new HeroAction();
action1.Move(); // Move in HeroAction

IAction action2 = new HeroAction();
action2.Move(); // Move in HeroAction
```
* Вариант 2 - сокрытие метода в производном классе
```java
interface IAction {...}
class BaseAction : IAction {
  public void Move() {...}
}
class HeroAction : BaseAction {
  public new void Move() {...}
}
// применение
BaseAction action1 = new HeroAction();
action1.Move(); // Move in BaseAction

IAction action2 = new HeroAction();
action2.Move(); // Move in BaseAction
```
* Вариант 3 - повторная реализация интерфейса в классе-наследнике
```java
interface IAction {...}
class BaseAction : IAction {...}
class HeroAction : BaseAction, IAction {
  public new void Move() {...}
}
// применение
BaseAction action1 = new HeroAction();
action1.Move(); // Move in BaseAction

IAction action2 = new HeroAction();
action2.Move(); // Move in HeroAction
```

#### [&uarr;](#5)  <a name="5_2_2">Явная реализация интерфейсов (ЯРИ)</a>
* Указывается название элемента вместе с названием интерфейса
* Не может быть модификатора ***public***
```java
interface IAction { void Move(); }
class BaseAction : IAction {
  void IAction.Move() {...}
}
```
* При ЯРИ элементы не являются частью интерфейса класса
* Через объект класса напрямаую обратиться нельзя
```java
BaseAction action = new BaseAction();
((IAction)action).Move(); // необходимо приведение к типу IAction

// или так
IAction action2 = new BaseAction();
action2.Move();
```
* Применение ЯРИ : При нескольких интерфейсах с одинаковыми методами
```java
interface ISchool { void Study(); }
interface IUniversity { void Study(); }
class Person : ISchool, IUniversity {
  void ISchool.Study() {...}
  void IUniversity.Study() {...}
}
// использование
Person p = new Person();
((ISchool)p).Study();
((IUniversity)p).Study();
```
* Применение ЯРИ : Когда в базовом классе уже реализован интерфейс, но в производном классе нужно изменить его
```java
interface IAction { void Move(); }
class BaseAction : IAction {
  public void Move() {
    Console.WriteLine("Move in BaseAction");
  }
}
class HeroAction : BaseAction, IAction {
  void IAction.Move() {
    Console.WriteLine("Move in HeroAction");
  }
}
// применение
HeroAction action1 = new HeroAction();
action1.Move();             // Move in BaseAction
((IAction)action1).Move();  // Move in HeroAction

IAction action2 = new HeroAction();
action2.Move();             // Move in HeroAction
```

#### [&uarr;](#5)  <a name="5_3">Интерфейсы в обобщениях</a>
* Интерфейс может выступать в роли ограничения обобщения. Можно указать несколько интерфейсов.
```java
interface IAccount {
  int CurrentSum { get; }
  void Put(int sum);
  void Withdraw(int sum);
}
interface IClient {
  string Name { get; set; }
}
class Client : IAccount, IClient {
  int _sum;
  public Client(string name, int sum) { Name = name; _sum = sum; }
  public string Name { get; set; }
  public int CurrentSum { get { return _sum } }
  public void Put(int sum) { _sum += sum; }
  public void Withdraw(int sum) { if(sum <= _sum ) _sum -= sum; }
}
// тип T реализует сразу два интерфейса 
class Transaction<T> where T : IAccount, IClient {
  public void Operate(T acc1, T acc2, int sum) {
    if(acc1.CurrentSum >= sum) {
      acc1.Withdraw(sum);
      acc2.Put(sum);
    }
  }
}
// использование
Client account1 = new Client("Tom", 200);
Client account2 = new Client("Bob", 300);
Transaction<Client> transaction = new Transaction<Client>();
transaction.Operate(account1, account2, 150);

//-------------------------------------------
// Также Т может представлять интерфейс, который наследуется от двух интерфейсов
interface IClientAccount : IAccount, IClient {...}
class ClientAccount : IClientAccoun {
  int _sum;
  public Client(string name, int sum) { Name = name; _sum = sum; }
  public string Name { get; set; }
  public int CurrentSum { get { return _sum } }
  public void Put(int sum) { _sum += sum; }
  public void Withdraw(int sum) { if(sum <= _sum ) _sum -= sum; }
}
// использование
IClientAccount account3 = new ClientAccount("Alice", 400);
IClientAccount account4 = new ClientAccount("Kate", 500);
Transaction<IClientAccount> operation = new Transaction<IClientAccount>();
operation.Operate(account3, account4, 200);
```

#### [&uarr;](#5)  <a name="5_3_1">Обобщенные интерфейсы</a>
* Как и классы могут быть обобщенными
```java
interface IUser<T> { T id { get; } }
class User<T> : IUser<T> {
  T _id;
  public User(T id) { _id = id; }
  public T Id { get { return _id; } }
}
// использование
IUser<int> user1 = new User<int>(1512);         // user1.Id = 1512
IUser<string> user2 = new User<string>("1255"); // user2.Id = "1255"
```
* Также можно явно указать используемый тип для Т
```java
class IntUser : IUser<int> {
  int _id;
  public IntUser(int id) { _id = id; }
  public int Id { get { return _id; } }
}
```

#### [&uarr;](#5)  <a name="5_4">Копирование объектов. Интерфейс ICloneable</a>
* Для копирования объекта класса используется интерфейс ICloneable
```java
public interface ICloneable {
  object Clone();
}
class Company {
  public string Name { get; set; }
}
class Person : ICloneable {
  public string Name { get; set; }
  public int Age { get; set; }
  public Company Work { get; set; }
  public object Clone() {
    return new Person { Name = this.Name, Age = this.Age };
  }
}
// использование
Person p1 = new Person { Name = "Tom", Age = 23 };
Person p2 = (Person)p1.Clone(); // создание нового объекта p2 с данными из p1 
p2.Name = "Alice"; // p1.Name = "Tom"
```
* Два типа копирования :
  * Поверхностное(неглубокое) копирование :
    * Копировать нужно только примитивные типы данных
    * Специальный метод ***MemberwiseClone()***
  * Глубокое копирование :
    * Копировать нужно ссылочные типы данных
```java
// при поверхностном копировании (только примитивные типы)
// вместо
public object Clone() {
  return new Person { Name = this.Name, Age = this.Age };
}
// можно записать так
public object Clone() {
  return this.MemberwiseClone();
}

// при глубоком копировании нужно присваивать все элементы вручную
public object Clone() {
  Company company = new Company { Name = this.Work.Name };
  return new Person {
    Name = this.Name,
    Age = this.Age,
    Work = company
  };
}
```

#### [&uarr;](#5)  <a name="5_5">Сортировка объектов. Интерфейс IComparable</a>
* Для сортировки примитивных типов данных метод ***Sort()***
```java
int[] numbers = new int[] { 97, 45, 32, 65, 83, 23, 15 };
Array.Sort(numbers); // 15, 23, 32, 45, 65, 83, 97
```
* Для сортировки сложных объектов интерфейс ***IComparable***
```java
// имеет всего один метод
public interface IComparable {
  int CompareTo(object obj);
}
```
* Сравнение текущего объекта с объектом obj из параметра
* Возвращает один из трех вариантов числа типа ***int*** :
  * ***> 0*** - ***this*** должен быть перед объектом из параметра
  * ***= 0*** - оба объекта равны
  * ***< 0*** - ***this*** должен быть после объекта из параметра
* Обобщенная версия ***IComparable*** :
```java
class Person : IComparable<Person> {
  public string Name { get; set; }
  public int Age { get; set; }
  public int CompareTo(Person p) {
    return this.Name.CompareTo(p.Name);
  }
}
```

#### [&uarr;](#5)  <a name="5_5_1">Применение компаратора</a>
* Компаратор - ***IComparer*** - сравнивает два объекта obj1, obj2
```java
interface IComparer {
  int Compare(object obj1, object obj2);
}
```
* Возвращает один из трех вариантов числа типа ***int*** :
  * ***> 0*** - ***obj1*** > ***obj2***
  * ***= 0*** - оба объекта равны
  * ***< 0*** - ***obj1*** < ***obj2***
```java
class PeopleComparer : IComparer<Person> {
  public int Compare(Person p1, Person p2) {
    if(p1.Nme.Length > p2.Name.Length) 
      return 1;
    else if(p1.Name.Length < p2.Name.Length) 
      return -1;
    return 0;
  }
}
// использование
Person p1 = new Person { Name = "Bill", Age = 34 };
Person p2 = new Person { Name = "Tom", Age = 24 };
Person p3 = new Person { Name = "Alice", Age = 14 };

Person[] people = new Person[] { p1, p2, p3 };

// before [ "Bill", "Tom", "Alice" ]
Array.Sort(people, new PeopleComparer());
// after [ "Tom", "Bill", "Alice" ]
```

#### [&uarr;](#5)  <a name="5_6">Ковариантность и контравариантность обобщенных интерфейсов</a>
* Возможность использовать вместо одного типа другой, который выше или ниже в иерархии наследования
* Три варианта поведения с .NET 4.0
  * Ковариантность : более конкретный тип, чем заданный изначально
  * Контравариантность : более универсальный тип, чем заданный
  * Инвариантность : только заданный тип
* По умолчанию все обобщенные интерфейсы = ***инвариантным***
```java
class Account {
  public virtual void DoTransfer(int sum) {
    Console.WriteLine($"Клиент положил на счет {sum} долларов");
  }
}
class DepositAccount : Account {
  public override void DoTransfer(int sum) {
    Console.WriteLine($"Клиент положил на депозитный счет {sum} долларов")
  }
}
```

#### [&uarr;](#5)  <a name="5_6_1">Ковариантные интерфейсы</a>
* К универсальному параметру добавляется ***out***
```java
interface IBank<out T> 
{
  T CreateAccount(int sum);
}

class Bank<T> : IBank<T> where T : Account, new() 
{
  public T CreateAccount(int sum) 
  {
    T acc = new T(); // создаем счет
    acc.DoTransfer(sum);
    return acc;
  }
}
// использование
IBank<DepositAccount> depositBank = new Bank<DepositAccount>();
Account acc1 = depositBank.CreateAccount(34);

IBank<Account> ordinaryBank = new Bank<DepositAccount>(); // без out тут будет ошибка
// или так
// IBank<Account> ordinryBank = depositBank;
Account acc2 = ordinaryBank.CreateAccount(45);
```

#### [&uarr;](#5)  <a name="5_6_2">Контравариантные интерфейсы</a>
* К универсальному параметру добавляется ***in***
```java
interface ITransaction<in T> 
{
  void DoOperation(T account, int sum);
}

class Transaction<T> : ITransaction<T> where T : Account 
{
  public void DoOperation(T account, int sum) 
  {
    account.DoTransder(sum);
  }
}
// использование 
ITransaction<Account> accTransaction = new Transaction<Account>();
accTransaction.DoOperation(new Account(), 400);

// контравариантность дает возможность привести объект Transaction<Account> к типу ITransaction<DepositAccount>
ITransaction<DepositAccount> depAccTransaction = new Transaction<Account>(); // без in тут будет ошибка
depAccTransaction.DoOperation(new DepositAccount(), 450);
```

### [&uarr;](#6)  <a name="6">Делегаты, события и лямбды</a>

### [&uarr;](#6)  <a name="6_1">Делегаты</a>
* Объекты указывающие на методы (указатели на методы)
* Через делегаты можно вызывать методы